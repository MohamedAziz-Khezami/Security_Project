from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import os
import base64

# classic
app = FastAPI()

class TextKey(BaseModel):
    text: str
    key: int

@app.post("/caesar/encrypt")
def caesar_encrypt(body: TextKey):
    result = ""
    for c in body.text:
        if c.isalpha():
            base = 'A' if c.isupper() else 'a'
            result += chr((ord(c) - ord(base) + body.key) % 26 + ord(base))
        else:
            result += c
    return {"cipher": result}

@app.post("/caesar/decrypt")
def caesar_decrypt(body: TextKey):
    return caesar_encrypt(TextKey(text=body.text, key=26-body.key))


class XorBody(BaseModel):
    data: str
    key: str

@app.post("/xor/encrypt")
def xor_encrypt(body: XorBody):
    data = body.data.encode()
    key = body.key.encode()
    output = bytes([b ^ key[i % len(key)] for i, b in enumerate(data)])
    return {"cipher": base64.b64encode(output).decode()}

@app.post("/xor/decrypt")
def xor_decrypt(body: XorBody):
    raw = base64.b64decode(body.data)
    key = body.key.encode()
    output = bytes([b ^ key[i % len(key)] for i, b in enumerate(raw)])
    return {"text": output.decode()}


# modern symmetric
from Crypto.Cipher import DES, DES3, AES
from Crypto.Util.Padding import pad, unpad

class SymBody(BaseModel):
    data: str
    key: str  # base64 for AES/Fernet, raw for DES/3DES
    iv: str = None  # base64

@app.post("/des/encrypt")
def des_encrypt(body: SymBody):
    key = body.key.encode()
    iv = body.iv.encode()
    cipher = DES.new(key, DES.MODE_CBC, iv)
    ct = cipher.encrypt(pad(body.data.encode(), 8))
    return {"cipher": base64.b64encode(ct).decode()}

@app.post("/des/decrypt")
def des_decrypt(body: SymBody):
    key = body.key.encode()
    iv = body.iv.encode()
    cipher = DES.new(key, DES.MODE_CBC, iv)
    pt = unpad(cipher.decrypt(base64.b64decode(body.data)), 8)
    return {"text": pt.decode()}

@app.post("/3des/encrypt")
def triple_des_encrypt(body: SymBody):
    key = body.key.encode()
    iv = body.iv.encode()
    cipher = DES3.new(key, DES3.MODE_CBC, iv)
    ct = cipher.encrypt(pad(body.data.encode(), 8))
    return {"cipher": base64.b64encode(ct).decode()}

@app.post("/3des/decrypt")
def triple_des_decrypt(body: SymBody):
    key = body.key.encode()
    iv = body.iv.encode()
    cipher = DES3.new(key, DES3.MODE_CBC, iv)
    pt = unpad(cipher.decrypt(base64.b64decode(body.data)), 8)
    return {"text": pt.decode()}

@app.post("/aes/encrypt")
def aes_encrypt(body: SymBody):
    key = base64.b64decode(body.key)
    iv = base64.b64decode(body.iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ct = cipher.encrypt(pad(body.data.encode(), 16))
    return {"cipher": base64.b64encode(ct).decode()}

@app.post("/aes/decrypt")
def aes_decrypt(body: SymBody):
    key = base64.b64decode(body.key)
    iv = base64.b64decode(body.iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    pt = unpad(cipher.decrypt(base64.b64decode(body.data)), 16)
    return {"text": pt.decode()}


# Fernet
from cryptography.fernet import Fernet

@app.post("/fernet/encrypt")
def fernet_encrypt(body: BaseModel):
    data = body.text.encode()
    key = body.key  # generated by Fernet.generate_key()
    f = Fernet(key)
    token = f.encrypt(data)
    return {"cipher": token.decode()}

@app.post("/fernet/decrypt")
def fernet_decrypt(body: BaseModel):
    token = body.text.encode()
    key = body.key
    f = Fernet(key)
    pt = f.decrypt(token)
    return {"text": pt.decode()}


# RSA
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes

@app.post("/rsa/generate")
def rsa_generate():
    private = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    pem_priv = private.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption())
    pub = private.public_key()
    pem_pub = pub.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo)
    return {"private_key": pem_priv.decode(), "public_key": pem_pub.decode()}

class RsaBody(BaseModel):
    data: str
    key: str

@app.post("/rsa/encrypt")
def rsa_encrypt(body: RsaBody):
    pub = serialization.load_pem_public_key(body.key.encode())
    ct = pub.encrypt(body.data.encode(),
                     padding.OAEP(mgf=padding.MGF1(hashes.SHA256()),
                                  algorithm=hashes.SHA256(),
                                  label=None))
    return {"cipher": base64.b64encode(ct).decode()}

@app.post("/rsa/decrypt")
def rsa_decrypt(body: RsaBody):
    priv = serialization.load_pem_private_key(body.key.encode(), password=None)
    pt = priv.decrypt(base64.b64decode(body.data),
                      padding.OAEP(mgf=padding.MGF1(hashes.SHA256()),
                                   algorithm=hashes.SHA256(),
                                   label=None))
    return {"text": pt.decode()}


# hybrid
class HybridBody(BaseModel):
    data: str
    aes_key: str
    rsa_priv: str
    rsa_pub: str

@app.post("/hybrid/encrypt")
def hybrid_encrypt(body: HybridBody):
    # encrypt data
    key = base64.b64decode(body.aes_key)
    iv = os.urandom(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ct = cipher.encrypt(pad(body.data.encode(), 16))
    # encrypt key
    pub = serialization.load_pem_public_key(body.rsa_pub.encode())
    ek = pub.encrypt(key,
                     padding.OAEP(mgf=padding.MGF1(hashes.SHA256()),
                                  algorithm=hashes.SHA256(),
                                  label=None))
    return {
        "iv": base64.b64encode(iv).decode(),
        "cipher": base64.b64encode(ct).decode(),
        "encrypted_key": base64.b64encode(ek).decode()
    }

@app.post("/hybrid/decrypt")
def hybrid_decrypt(body: HybridBody):
    priv = serialization.load_pem_private_key(body.rsa_priv.encode(), password=None)
    key = priv.decrypt(base64.b64decode(body.aes_key),
                       padding.OAEP(mgf=padding.MGF1(hashes.SHA256()),
                                    algorithm=hashes.SHA256(),
                                    label=None))
    iv = base64.b64decode(body.data)  # misuse fields
    ct = base64.b64decode(body.rsa_pub)
    pt = unpad(AES.new(key, AES.MODE_CBC, iv).decrypt(ct), 16)
    return {"text": pt.decode()}
    